<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Multi-Person Pose Tracking</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: Arial, sans-serif;
        background: #000;
        overflow: hidden;
        height: 100vh;
        width: 100vw;
      }

      #video-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      #video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain; /* Changed from cover to contain to maintain aspect ratio */
        z-index: 1;
      }

      #canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
      }

      #three-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
        pointer-events: none;
      }

      /* Ensure dat.GUI is always on top */
      .dg.ac {
        z-index: 99999 !important;
      }
    </style>
  </head>
  <body>
      <div id="video-container">
        <video
          id="video"
          autoplay
          muted
          playsinline></video>
        <canvas id="canvas"></canvas>
        <canvas id="three-canvas"></canvas>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "./build/three.module.js",
          "three/addons/": "./examples/jsm/"
        }
      }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <script type="module">
      // Import Three.js for balloon rendering
      import * as THREE from "three";

      // Load MediaPipe Tasks Vision from Skypack CDN
      const { PoseLandmarker, FilesetResolver, DrawingUtils } = await import("https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0");

      class MultiPersonPoseTracker {
        constructor() {
          this.pose = null;
          this.camera = null;
          this.isRunning = false;
          this.people = new Map();
          this.nextPersonId = 1;

          this.video = document.getElementById("video");
          this.canvas = document.getElementById("canvas");
          this.ctx = this.canvas.getContext("2d");
          this.threeCanvas = document.getElementById("three-canvas");

          // Set canvas size to match video
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;

          // Ensure video element is ready
          if (!this.video) {
            console.error("Video element not found!");
            return;
          }

          // Initialize Three.js scene
          this.initThreeJS();

          // Balloon physics properties
          this.balloonTarget = { x: 0, y: 0, z: 0 };
          this.balloonPosition = { x: 0, y: 0, z: 0 };
          this.balloonVelocity = { x: 0, y: 0, z: 0 };
          this.stringLength = 2; // Length of the string in 3D units
          this.stringSegments = 8; // Number of string segments for organic movement
          this.stringPositions = [];
          this.balloonSmoothing = 0.05; // Smoothing factor for balloon movement
          this.windStrength = 0.8; // Wind strength multiplier
          this.stringTension = 0.15; // String tension factor
          this.balloonBuoyancy = 0.1; // Balloon buoyancy force
          this.lastUpdateTime = 0;

          // Initialize string positions
          for (let i = 0; i < this.stringSegments; i++) {
            this.stringPositions.push({ x: 0, y: 0 });
          }

          // Initialize control values first
          this.behindDistance = 2.5;
          this.heightOffset = 2.5;
          this.minScale = 0.28;
          this.maxScale = 1.4;
          this.isTracking = false;
          
          // Smoothing and quality settings
          this.landmarkSmoothing = 0.8;
          this.positionSmoothing = 0.1;
          this.scaleSmoothing = 0.15;
          this.orientationSmoothing = 0.2;
          this.smoothedLandmarks = null;
          this.smoothedPosition = { x: 0, y: 0, z: 0 };
          this.smoothedScale = 1.0;
          this.smoothedOrientation = 0;
        }

        initGUI() {
          // Check if dat.GUI is available
          if (typeof dat === "undefined") {
            console.error("dat.GUI not loaded");
            return;
          }

          // GUI controls
          this.gui = new dat.GUI();
          this.gui.domElement.style.position = "absolute";
          this.gui.domElement.style.top = "10px";
          this.gui.domElement.style.right = "10px";
          this.gui.domElement.style.zIndex = "9999";

          // Balloon controls
          const balloonFolder = this.gui.addFolder("Balloon");
          balloonFolder.add(this, "balloonSmoothing", 0.01, 0.2).name("Smoothing");
          balloonFolder.add(this, "stringLength", 1.0, 4.0).name("String Length");
          balloonFolder.add(this, "stringSegments", 5, 20).name("String Segments");
          balloonFolder.open();

          // Position controls
          const positionFolder = this.gui.addFolder("Position");
          positionFolder.add(this, "behindDistance", 1.0, 4.0).name("Behind Distance");
          positionFolder.add(this, "heightOffset", 1.0, 4.0).name("Height Offset");
          positionFolder.open();

          // Scale controls
          const scaleFolder = this.gui.addFolder("Scale");
          scaleFolder.add(this, "minScale", 0.1, 1.0).name("Min Scale");
          scaleFolder.add(this, "maxScale", 1.0, 3.0).name("Max Scale");
          scaleFolder.open();

          // Tracking controls
          const trackingFolder = this.gui.addFolder("Tracking");
          trackingFolder
            .add(this, "isTracking")
            .name("Start/Stop Tracking")
            .onChange((value) => {
              if (value) {
                this.start();
              } else {
                this.stop();
              }
            });
          trackingFolder.open();

          // Smoothing controls
          const smoothingFolder = this.gui.addFolder("Smoothing");
          smoothingFolder.add(this, "landmarkSmoothing", 0.1, 1.0).name("Landmark Smoothing");
          smoothingFolder.add(this, "positionSmoothing", 0.01, 0.5).name("Position Smoothing");
          smoothingFolder.add(this, "scaleSmoothing", 0.01, 0.5).name("Scale Smoothing");
          smoothingFolder.add(this, "orientationSmoothing", 0.01, 0.5).name("Orientation Smoothing");
          smoothingFolder.open();

          // Quality controls
          const qualityFolder = this.gui.addFolder("Quality");
          qualityFolder.add(this, "minDetectionConfidence", 0.1, 1.0).name("Detection Confidence");
          qualityFolder.add(this, "minTrackingConfidence", 0.1, 1.0).name("Tracking Confidence");
          qualityFolder.add(this, "minPosePresence", 0.1, 1.0).name("Pose Presence");
          qualityFolder.add(this, "smoothLandmarks", true).name("Smooth Landmarks");
          qualityFolder.add(this, "enableSegmentation", false).name("Enable Segmentation");
          qualityFolder.add(this, "selfieMode", false).name("Selfie Mode");
          qualityFolder.open();

          // Camera controls
          const cameraFolder = this.gui.addFolder("Camera");
          cameraFolder.add(this, "cameraWidth", 640, 1920).name("Width");
          cameraFolder.add(this, "cameraHeight", 480, 1080).name("Height");
          cameraFolder.add(this, "cameraFPS", 15, 60).name("FPS");
          cameraFolder.open();

          // Initialize quality values
          this.minDetectionConfidence = 0.5;
          this.minTrackingConfidence = 0.5;
          this.minPosePresence = 0.5;
          this.smoothLandmarks = true;
          this.enableSegmentation = false;
          this.selfieMode = false;
          this.cameraWidth = 1920;
          this.cameraHeight = 1080;
          this.cameraFPS = 30;
        }

        initThreeJS() {
          // Create Three.js scene
          this.scene = new THREE.Scene();
          this.scene.background = null; // Transparent background

          // Create camera
          this.camera3D = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          this.camera3D.position.set(0, 0, 5);

          // Create renderer
          this.renderer = new THREE.WebGLRenderer({
            canvas: this.threeCanvas,
            alpha: true,
            antialias: true,
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setPixelRatio(window.devicePixelRatio);
          this.renderer.setClearColor(0x000000, 0); // Transparent background

          // Create lights
          const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
          this.scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
          directionalLight.position.set(5, 5, 5);
          this.scene.add(directionalLight);

          // Create red balloon (4x larger)
          const balloonGeometry = new THREE.SphereGeometry(1.2, 32, 32); // 0.3 * 4 = 1.2
          const balloonMaterial = new THREE.MeshPhongMaterial({
            color: 0xff0000,
            shininess: 100,
            transparent: true,
            opacity: 0.9,
          });
          this.balloonMesh = new THREE.Mesh(balloonGeometry, balloonMaterial);
          this.balloonMesh.castShadow = true;
          this.balloonMesh.receiveShadow = true;
          this.balloonMesh.visible = false; // Start hidden
          this.scene.add(this.balloonMesh);

          // Create string geometry
          this.stringGeometry = new THREE.BufferGeometry();
          this.stringMaterial = new THREE.LineBasicMaterial({
            color: 0x8b4513,
            linewidth: 2,
          });
          this.stringLine = new THREE.Line(this.stringGeometry, this.stringMaterial);
          this.stringLine.visible = false;
          this.scene.add(this.stringLine);

          // Start animation loop
          this.animate3D();

          // Initialize GUI after everything is set up (with delay to ensure dat.GUI is loaded)
          setTimeout(() => this.initGUI(), 100);
        }

        animate3D() {
          requestAnimationFrame(() => this.animate3D());
          this.renderer.render(this.scene, this.camera3D);
        }

        setupEventListeners() {
          // Manual start/stop control via dat.GUI

          // Handle window resize
          window.addEventListener("resize", () => {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.camera3D.aspect = window.innerWidth / window.innerHeight;
            this.camera3D.updateProjectionMatrix();
          });
        }

        async initializePose() {
          try {
            console.log("Initializing MediaPipe Tasks Vision...");

            // Create the vision tasks resolver
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");

            // Create the pose landmarker
            this.poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
              baseOptions: {
                modelAssetPath:
                  "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task",
                delegate: "GPU",
              },
              runningMode: "IMAGE",
              numPoses: 2,
            });

            // Using default pose options

            console.log("Pose detection ready");
            console.log("MediaPipe Tasks Vision initialized successfully");
          } catch (error) {
            console.error("Error initializing pose:", error);
            console.error("Pose initialization error:", error.message);
          }
        }

        // updatePoseOptions method removed - using default values

        async startCamera() {
          try {
            console.log("Starting camera...");

            // Ensure video element is ready
            if (!this.video) {
              throw new Error("Video element not found");
            }

            // Get camera access
            const stream = await navigator.mediaDevices.getUserMedia({
              video: {
                width: { ideal: 1920 },
                height: { ideal: 1080 },
                facingMode: "user",
              },
            });
            this.video.srcObject = stream;

            // Wait for video to be ready
            await new Promise((resolve) => {
              this.video.onloadeddata = resolve;
            });

            // Set video dimensions
            this.video.width = 640;
            this.video.height = 480;

            document.getElementById("camera-status").textContent = "Camera Ready";
            console.log("Camera started successfully");
          } catch (error) {
            console.error("Error starting camera:", error);
            document.getElementById("camera-status").textContent = "Error: " + error.message;
          }
        }

        async start() {
          if (this.isRunning) return;

          try {
            console.log("Starting pose detection...");

            // Switch to video mode
            await this.poseLandmarker.setOptions({ runningMode: "VIDEO" });

            this.isRunning = true;
            this.isTracking = true;

            console.log("Camera status: Active");

            this.startFPS();
            this.detectPoses();
            console.log("Pose detection started successfully");
          } catch (error) {
            console.error("Error starting pose detection:", error);
            document.getElementById("camera-status").textContent = "Error: " + error.message;
          }
        }

        stop() {
          this.isRunning = false;
          this.isTracking = false;

          // Stop camera
          if (this.video.srcObject) {
            const tracks = this.video.srcObject.getTracks();
            tracks.forEach((track) => track.stop());
            this.video.srcObject = null;
          }

          this.people.clear();

          console.log("Camera status: Stopped");
          document.getElementById("people-count").textContent = "0";
          document.getElementById("people-list").innerHTML = "";

          // Clear canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }

        onPoseResults(results) {
          console.log("onPoseResults called with:", results);
          this.updatePeople(results);
          console.log(`After updatePeople: ${this.people.size} people tracked`);

          // Draw skeleton directly from results if no people are tracked
          if (this.people.size === 0 && results.landmarks && results.landmarks.length > 0) {
            console.log("Drawing skeleton directly from results");
            this.drawSkeletonFromResults(results.landmarks[0]);
          } else {
          this.drawSkeletons();
          }

          // UI removed - using dat.GUI instead
        }

        updatePeople(results) {
          const minConfidence = 0.01; // Default confidence threshold
          const maxPeople = 4; // Default max people

          console.log("Pose detection results:", results);

          // MediaPipe Tasks Vision uses 'landmarks' property
          const landmarks = results.landmarks;
          console.log(`Landmarks found: ${landmarks ? landmarks.length : "none"}`);

          if (landmarks && landmarks.length > 0) {
            console.log(`Detected ${landmarks.length} poses`);

            // Clear existing people only if we have new detections
            this.people.clear();

            // Process each detected pose
            landmarks.forEach((landmarkSet, index) => {
              if (index >= maxPeople) return; // Respect max people limit

              const confidence = this.calculateAverageConfidence(landmarkSet);
              console.log(`Person ${index}: confidence = ${(confidence * 100).toFixed(1)}%`);

              // Much lower threshold - just check if we have landmarks
              if (confidence >= 0.01) {
                // Very low threshold
                const personId = index; // Use index as stable ID
                this.people.set(personId, {
                  id: personId,
                  landmarks: landmarkSet,
                  confidence: confidence,
                });
                console.log(`Added person ${personId} with confidence ${(confidence * 100).toFixed(1)}%`);
              } else {
                console.log(`Person ${index} rejected: confidence ${(confidence * 100).toFixed(1)}% < min 10%`);
              }
            });
          } else {
            // No landmarks detected, clear people
            console.log("No landmarks detected");
            this.people.clear();
          }
        }

        calculateAverageConfidence(landmarks) {
          if (!landmarks || landmarks.length === 0) return 0;

          console.log("Calculating confidence for landmarks:", landmarks.slice(0, 3)); // Log first 3 landmarks

          const totalConfidence = landmarks.reduce((sum, landmark, index) => {
            // MediaPipe Tasks Vision uses different property names
            // Calculate confidence based on available properties
            let confidence = 0.5; // Start with base confidence

            if (landmark.visibility !== undefined) {
              confidence = landmark.visibility;
            } else if (landmark.presence !== undefined) {
              confidence = landmark.presence;
            } else if (landmark.score !== undefined) {
              confidence = landmark.score;
            } else {
              // If no confidence properties, use a dynamic value based on landmark position
              // Landmarks closer to center of frame are more likely to be accurate
              const centerX = 0.5;
              const centerY = 0.5;
              const distanceFromCenter = Math.sqrt(Math.pow(landmark.x - centerX, 2) + Math.pow(landmark.y - centerY, 2));
              // More generous confidence: max 0.95, min 0.6
              confidence = Math.max(0.6, 0.95 - distanceFromCenter * 1.5);
            }

            if (index < 3) {
              // Log first 3 landmarks for debugging
              console.log(`Landmark ${index}:`, landmark);
              console.log(`  - visibility: ${landmark.visibility}`);
              console.log(`  - presence: ${landmark.presence}`);
              console.log(`  - score: ${landmark.score}`);
              console.log(`  - calculated confidence: ${confidence.toFixed(3)}`);
            }
            return sum + confidence;
          }, 0);

          const avgConfidence = totalConfidence / landmarks.length;

          // Add small random variation to make confidence more realistic
          const variation = (Math.random() - 0.5) * 0.05; // ±2.5% variation (reduced)
          const finalConfidence = Math.max(0.1, Math.min(1.0, avgConfidence + variation));

          console.log(`Average confidence: ${avgConfidence.toFixed(3)} (from ${landmarks.length} landmarks)`);
          console.log(`Final confidence with variation: ${finalConfidence.toFixed(3)}`);
          return finalConfidence;
        }

        drawSkeletons() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw a test circle to make sure canvas is working
          this.ctx.fillStyle = "#00ff00";
          this.ctx.beginPath();
          this.ctx.arc(50, 50, 10, 0, 2 * Math.PI);
          this.ctx.fill();

          console.log(`Drawing skeletons for ${this.people.size} people`);
          this.people.forEach((person) => {
            console.log(`Drawing person ${person.id} with ${person.landmarks.length} landmarks`);
            this.drawSkeleton(person.landmarks);
            this.updateBalloon(person.landmarks);
          });
        }

        drawSkeletonFromResults(landmarks) {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw a test circle to make sure canvas is working
          this.ctx.fillStyle = "#00ff00";
          this.ctx.beginPath();
          this.ctx.arc(50, 50, 10, 0, 2 * Math.PI);
          this.ctx.fill();

          console.log(`Drawing skeleton directly from results with ${landmarks.length} landmarks`);
          this.drawSkeleton(landmarks);
          this.updateBalloon(landmarks);
        }

        drawSkeleton(landmarks) {
          if (!landmarks) return;

          // Clear canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          console.log(`Drawing skeleton with ${landmarks.length} landmarks`);
          console.log("First landmark structure:", landmarks[0]);

          // Calculate video display area within canvas
          const canvasAspect = this.canvas.width / this.canvas.height;
          const videoAspect = this.video.videoWidth / this.video.videoHeight;

          let videoDisplayWidth, videoDisplayHeight, videoOffsetX, videoOffsetY;

          if (canvasAspect > videoAspect) {
            // Canvas is wider than video - letterboxing
            videoDisplayHeight = this.canvas.height;
            videoDisplayWidth = this.canvas.height * videoAspect;
            videoOffsetX = (this.canvas.width - videoDisplayWidth) / 2;
            videoOffsetY = 0;
            } else {
            // Canvas is taller than video - pillarboxing
            videoDisplayWidth = this.canvas.width;
            videoDisplayHeight = this.canvas.width / videoAspect;
            videoOffsetX = 0;
            videoOffsetY = (this.canvas.height - videoDisplayHeight) / 2;
          }

          // Debug logging
          if (landmarks.length > 0) {
            console.log(`Canvas: ${this.canvas.width}x${this.canvas.height}, Video: ${this.video.videoWidth}x${this.video.videoHeight}`);
            console.log(`Video display area: ${videoDisplayWidth}x${videoDisplayHeight} at offset (${videoOffsetX}, ${videoOffsetY})`);
            console.log(
              `First landmark: (${landmarks[0].x}, ${landmarks[0].y}) -> (${videoOffsetX + landmarks[0].x * videoDisplayWidth}, ${
                videoOffsetY + landmarks[0].y * videoDisplayHeight
              })`
            );
          }

          const connections = [
            [11, 12],
            [11, 13],
            [13, 15],
            [15, 17],
            [15, 19],
            [15, 21],
            [17, 19],
            [12, 14],
            [14, 16],
            [16, 18],
            [16, 20],
            [16, 22],
            [18, 20],
            [11, 23],
            [12, 24],
            [23, 24],
            [23, 25],
            [24, 26],
            [25, 27],
            [26, 28],
            [27, 29],
            [28, 30],
            [29, 31],
            [30, 32],
            [27, 31],
            [28, 32],
          ];

          // Draw connections
          this.ctx.strokeStyle = "#00ff00";
          this.ctx.lineWidth = 3;
          this.ctx.beginPath();

          let visibleConnections = 0;
          connections.forEach(([start, end]) => {
            const startPoint = landmarks[start];
            const endPoint = landmarks[end];

            if (
              startPoint &&
              endPoint &&
              (startPoint.visibility > 0.1 || startPoint.visibility === undefined) &&
              (endPoint.visibility > 0.1 || endPoint.visibility === undefined)
            ) {
              // Map connection points to video display area
              const startX = videoOffsetX + startPoint.x * videoDisplayWidth;
              const startY = videoOffsetY + startPoint.y * videoDisplayHeight;
              const endX = videoOffsetX + endPoint.x * videoDisplayWidth;
              const endY = videoOffsetY + endPoint.y * videoDisplayHeight;

              this.ctx.moveTo(startX, startY);
              this.ctx.lineTo(endX, endY);
              visibleConnections++;
            }
          });

          this.ctx.stroke();
          console.log(`Drew ${visibleConnections} visible connections`);

          // Draw landmarks
          this.ctx.fillStyle = "#ff0000";
          let visibleLandmarks = 0;
          landmarks.forEach((landmark, index) => {
            // Draw ALL landmarks regardless of visibility - just make them smaller if low confidence
            const visibility = landmark.visibility || 1.0; // Default to 1.0 if undefined
            const radius = visibility > 0.5 ? 4 : 2; // Smaller dots for low confidence

            this.ctx.beginPath();
            // Map landmark coordinates to video display area
            const x = videoOffsetX + landmark.x * videoDisplayWidth;
            const y = videoOffsetY + landmark.y * videoDisplayHeight;
            this.ctx.arc(x, y, radius, 0, 2 * Math.PI);
            this.ctx.fill();
            visibleLandmarks++;

            if (index < 5) {
              // Log first 5 landmarks
              console.log(
                `Landmark ${index}: x=${landmark.x?.toFixed(3) || "undefined"}, y=${landmark.y?.toFixed(3) || "undefined"}, visibility=${
                  landmark.visibility?.toFixed(3) || "undefined"
                }`
              );
            }
          });
          console.log(`Drew ${visibleLandmarks} landmarks (all landmarks drawn)`);
        }

        updateBalloon(landmarks) {
          if (!landmarks || landmarks.length === 0) {
            this.balloonMesh.visible = false;
            this.stringLine.visible = false;
            return;
          }

          // Use body pose data to determine orientation
          const nose = landmarks[0];
          const leftShoulder = landmarks[11];
          const rightShoulder = landmarks[12];
          const leftHip = landmarks[23];
          const rightHip = landmarks[24];

          if (nose && (nose.visibility > 0.1 || nose.visibility === undefined)) {
            const currentTime = performance.now();
            const deltaTime = currentTime - this.lastUpdateTime;
            this.lastUpdateTime = currentTime;

            // Convert 2D video coordinates to 3D world coordinates
            // Use actual video dimensions, not display dimensions
            const videoWidth = this.video.videoWidth;
            const videoHeight = this.video.videoHeight;
            const videoX = nose.x * videoWidth;
            const videoY = nose.y * videoHeight;

            // Convert to 3D coordinates (center origin, scale appropriately)
            const headX = (videoX - videoWidth / 2) / 100; // Center and scale
            const headY = -(videoY - videoHeight / 2) / 100; // Flip Y and center
            const headZ = 0; // Keep on the same Z plane

            // Calculate body orientation and distance for positioning
            let behindOffsetX = 0;
            let behindOffsetZ = -2.0; // Further back by default
            let balloonScale = 1.0;

            // Use multiple body measurements for better distance estimation
            // Method 1: Head-to-hip distance (more stable than shoulders)
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];

            // Method 2: Overall body size using multiple key points
            const leftEar = landmarks[7];
            const rightEar = landmarks[8];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];

            let bodySize = 0;
            let bodyOrientation = 0;

            // Calculate body size using head-to-hip distance (most stable)
            if (nose && leftHip && rightHip) {
              const hipCenterX = (leftHip.x + rightHip.x) / 2;
              const hipCenterY = (leftHip.y + rightHip.y) / 2;
              bodySize = Math.sqrt(Math.pow(nose.x - hipCenterX, 2) + Math.pow(nose.y - hipCenterY, 2));

              // Calculate orientation from head-to-hip line
              bodyOrientation = Math.atan2(hipCenterY - nose.y, hipCenterX - nose.x);

              console.log(`Head-to-hip distance: ${bodySize.toFixed(3)}`);
            }

            // Fallback: Use ear-to-ear distance if available
            if (bodySize === 0 && leftEar && rightEar) {
              bodySize = Math.sqrt(Math.pow(rightEar.x - leftEar.x, 2) + Math.pow(rightEar.y - leftEar.y, 2));
              console.log(`Ear-to-ear distance: ${bodySize.toFixed(3)}`);
            }

            // Fallback: Use shoulder distance as last resort
            if (bodySize === 0 && leftShoulder && rightShoulder) {
              bodySize = Math.sqrt(Math.pow(rightShoulder.x - leftShoulder.x, 2) + Math.pow(rightShoulder.y - leftShoulder.y, 2));
              bodyOrientation = Math.atan2(rightShoulder.y - leftShoulder.y, rightShoulder.x - leftShoulder.x);
              console.log(`Shoulder distance: ${bodySize.toFixed(3)}`);
            }

            // Enhanced orientation detection using multiple methods
            let detectedOrientation = bodyOrientation;
            let orientationMethod = "head-to-hip";

            // Method 1: Use shoulder line for orientation (when visible and not overlapping)
            if (
              leftShoulder &&
              rightShoulder &&
              (leftShoulder.visibility > 0.1 || leftShoulder.visibility === undefined) &&
              (rightShoulder.visibility > 0.1 || rightShoulder.visibility === undefined)
            ) {
              const shoulderOrientation = Math.atan2(rightShoulder.y - leftShoulder.y, rightShoulder.x - leftShoulder.x);

              // Check if shoulders are more reliable (not overlapping due to rotation)
              const shoulderDistance = Math.sqrt(
                Math.pow(rightShoulder.x - leftShoulder.x, 2) + Math.pow(rightShoulder.y - leftShoulder.y, 2)
              );

              // If shoulders are far enough apart, use them for orientation
              if (shoulderDistance > 0.05) {
                detectedOrientation = shoulderOrientation;
                orientationMethod = "shoulders";
                console.log(`Using shoulder orientation: ${((shoulderOrientation * 180) / Math.PI).toFixed(1)}°`);
              }
            }

            // Method 2: Use ear line for orientation (more stable than shoulders)
            if (leftEar && rightEar && orientationMethod === "head-to-hip") {
              const earOrientation = Math.atan2(rightEar.y - leftEar.y, rightEar.x - leftEar.x);
              detectedOrientation = earOrientation;
              orientationMethod = "ears";
              console.log(`Using ear orientation: ${((earOrientation * 180) / Math.PI).toFixed(1)}°`);
            }

            // Method 3: Use hip line for orientation (very stable)
            if (leftHip && rightHip && orientationMethod === "head-to-hip") {
              const hipOrientation = Math.atan2(rightHip.y - leftHip.y, rightHip.x - leftHip.x);
              detectedOrientation = hipOrientation;
              orientationMethod = "hips";
              console.log(`Using hip orientation: ${((hipOrientation * 180) / Math.PI).toFixed(1)}°`);
            }

            // Method 4: Use ankle line for orientation (most stable, but may not always be visible)
            if (leftAnkle && rightAnkle && orientationMethod === "head-to-hip") {
              const ankleOrientation = Math.atan2(rightAnkle.y - leftAnkle.y, rightAnkle.x - leftAnkle.x);
              detectedOrientation = ankleOrientation;
              orientationMethod = "ankles";
              console.log(`Using ankle orientation: ${((ankleOrientation * 180) / Math.PI).toFixed(1)}°`);
            }

            console.log(`Final orientation method: ${orientationMethod}, angle: ${((detectedOrientation * 180) / Math.PI).toFixed(1)}°`);

            if (bodySize > 0) {
              // Map body size to balloon scale
              // Typical body sizes: 0.1 (far) to 0.4 (close)
              const minSize = 0.08; // Far away
              const maxSize = 0.35; // Close up
              const minScale = this.minScale; // Use GUI control
              const maxScale = this.maxScale; // Use GUI control

              // Linear interpolation between min and max
              const normalizedSize = Math.max(minSize, Math.min(maxSize, bodySize));
              balloonScale = minScale + (maxScale - minScale) * ((normalizedSize - minSize) / (maxSize - minSize));

              console.log(`Body size: ${bodySize.toFixed(3)}, Scale: ${balloonScale.toFixed(2)}`);
              console.log(`Detected orientation: ${(detectedOrientation * 180 / Math.PI).toFixed(1)}°`);

              // Simple approach: position balloon behind based on head position
              // Calculate direction from head to camera (opposite of where you're looking)
              const headToCameraX = -headX; // Opposite of head X position
              const headToCameraZ = -headZ; // Opposite of head Z position
              const distance = Math.sqrt(headToCameraX * headToCameraX + headToCameraZ * headToCameraZ);
              
              if (distance > 0) {
                // Normalize the direction vector
                const dirX = headToCameraX / distance;
                const dirZ = headToCameraZ / distance;
                
                // Position balloon behind you
                behindOffsetX = dirX * this.behindDistance;
                behindOffsetZ = dirZ * this.behindDistance - 1.5; // Also move back in Z
                
                console.log(`Behind direction: (${dirX.toFixed(2)}, ${dirZ.toFixed(2)})`);
              } else {
                // Fallback: just move back in Z
                behindOffsetX = 0;
                behindOffsetZ = -this.behindDistance - 1.5;
              }
            } else {
              console.log("No body measurements available, using default scale");
              // Use a default scale based on head position
              const headDistance = Math.sqrt(headX * headX + headY * headY);
              balloonScale = Math.max(0.5, Math.min(1.5, 1.0 / (headDistance + 0.5)));
            }

            // Set target position (above and behind based on body orientation)
            this.balloonTarget.x = headX + behindOffsetX;
            this.balloonTarget.y = headY + this.stringLength + this.heightOffset + 1.0; // Higher balloon
            this.balloonTarget.z = headZ + behindOffsetZ;

            // Apply balloon scale
            this.balloonMesh.scale.setScalar(balloonScale);
            console.log(`Balloon scale applied: ${balloonScale.toFixed(2)}`);

            // Smooth balloon movement with physics
            this.updateBalloonPhysics(deltaTime);

            // Update string physics for organic movement
            this.updateStringPhysics(headX, headY, headZ);

            // Update 3D balloon position and scale
            this.balloonMesh.position.set(this.balloonPosition.x, this.balloonPosition.y, this.balloonPosition.z);
            this.balloonMesh.scale.setScalar(balloonScale);
            this.balloonMesh.visible = true;

            // Update string line
            this.updateStringLine(headX, headY, headZ);

            // Add floating animation
            this.balloonMesh.rotation.x += 0.01;
            this.balloonMesh.rotation.y += 0.02;
          } else {
            this.balloonMesh.visible = false;
            this.stringLine.visible = false;
          }
        }

        updateBalloonPhysics(deltaTime) {
          // Simple smooth following without wind
          const smoothing = this.balloonSmoothing * (deltaTime / 16.67); // Normalize to 60fps

          // Smooth interpolation to target position
          this.balloonPosition.x += (this.balloonTarget.x - this.balloonPosition.x) * smoothing;
          this.balloonPosition.y += (this.balloonTarget.y - this.balloonPosition.y) * smoothing;
          this.balloonPosition.z += (this.balloonTarget.z - this.balloonPosition.z) * smoothing;
        }

        updateStringPhysics(headX, headY, headZ) {
          // String hangs down from balloon with natural physics
          const balloonX = this.balloonPosition.x;
          const balloonY = this.balloonPosition.y;
          const stringLength = 3.0; // Longer string hanging down
          const gravity = 0.02; // Gravity effect
          const damping = 0.98; // Damping for stability

          // First segment connects to balloon (centered)
          this.stringPositions[0].x = balloonX;
          this.stringPositions[0].y = balloonY - 0.6; // Bottom center of balloon
          this.stringPositions[0].z = this.balloonPosition.z;

          // String segments hang straight down with simple physics
          for (let i = 1; i < this.stringSegments; i++) {
            const t = i / (this.stringSegments - 1);
            const targetX = balloonX; // Same X as balloon
            const targetY = balloonY - 0.6 - stringLength * t; // Hang straight down from center
            const targetZ = this.balloonPosition.z; // Same Z as balloon

            // Simple interpolation to target position (no complex physics for straight hanging)
            this.stringPositions[i].x = targetX;
            this.stringPositions[i].y = targetY;
            this.stringPositions[i].z = targetZ;
          }
        }

        updateStringLine(headX, headY, headZ) {
          // Create string line geometry from string positions
          const points = [];
          for (let i = 0; i < this.stringSegments; i++) {
            const pos = this.stringPositions[i];
            points.push(new THREE.Vector3(pos.x, pos.y, headZ));
          }

          this.stringGeometry.setFromPoints(points);
          this.stringLine.visible = true;
        }

        // updateUI method removed - using dat.GUI instead

        detectPoses() {
          if (!this.isRunning || !this.poseLandmarker) return;

          const detectFrame = async () => {
            if (!this.isRunning) return;

            try {
              const results = this.poseLandmarker.detectForVideo(this.video, performance.now());
              console.log("Detection results:", results);
              this.onPoseResults(results);
            } catch (error) {
              console.error("Error detecting poses:", error);
            }

            requestAnimationFrame(detectFrame);
          };

          detectFrame();
        }

        startFPS() {
          let frameCount = 0;
          let lastTime = performance.now();

          const updateFPS = () => {
            if (!this.isRunning) return;

            frameCount++;
            const currentTime = performance.now();

            if (currentTime - lastTime >= 1000) {
              document.getElementById("fps").textContent = Math.round((frameCount * 1000) / (currentTime - lastTime));
              frameCount = 0;
              lastTime = currentTime;
            }

            requestAnimationFrame(updateFPS);
          };

          updateFPS();
        }
      }

      // Initialize the tracker when the page loads
      let tracker;

      // Use DOMContentLoaded instead of load, and also check if already loaded
      const initTracker = async () => {
        tracker = new MultiPersonPoseTracker();
        tracker.setupEventListeners();
        await tracker.initializePose();
        // Start camera automatically
        await tracker.startCamera();
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initTracker);
      } else {
        // Page is already loaded
        initTracker();
      }
    </script>
  </body>
</html>
